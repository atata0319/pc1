<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8">
  <link rel="stylesheet" href="eight-bit-color-picker.min.css">
  <script src="eight-bit-color-picker.min.js"></script>
  <script>
const LOCALSTORAGE_KEY_SETTINGS = 'settings2';
const LOCALSTORAGE_KEY_STROKES = 'strokes2';
const LOCALSTORAGE_KEY_SETTINGS_OLD = 'settings';
const LOCALSTORAGE_KEY_STROKES_OLD = 'strokes';
const layers = new Array();
let picker = null;
let lineWidth = 1;
let lineCount = 0;
let layerId = 1;
let targetLater = null;
let prevX = null;
let prevY = null;
let strokes;
let undoBuffer;

class Point {
  constructor(x, y) {
    this.x = x;
    this.y = y;
  }
  equals(other) {
    return this.x === other.x && this.y === other.y;
  }
}

class StrokeData {
  constructor(tl, lw, lc, x1, y1, x2, y2) {
    this.targetLater = tl.layerid;
    this.lineWidth = lw;
    this.lineColor = lc;
    this.pt1 = new Point(x1, y1);
    this.pt2 = new Point(x2, y2);
  }
}

window.addEventListener('load', () => {

  picker = new EightBitColorPicker({ el: 'ebcp', color: 0 });
  picker.addEventListener('colorChange', function(e) {
    //console.log('Old Color: ' + e.detail.oldColor)
    //console.log('New Color: ' + e.detail.newColor)
    //console.log('8bit Color: ' + e.detail.picker.get8BitColor())
    //console.log('Hex Color: ' + e.detail.picker.getHexColor())
    saveSettings();
    setTimeout(() => {
      e.detail.picker.hide();
    }, 50);
  });

  document.all.lineWidth1.addEventListener('click', () => {
    document.all.lineWidth3.style.border = "";
    document.all.lineWidth7.style.border = "";
    document.all.lineWidth15.style.border = "";
    document.all.lineWidth1.style.border = "solid 1px black";
    lineWidth = 1;
    saveSettings();
  });

  document.all.lineWidth3.addEventListener('click', () => {
    document.all.lineWidth1.style.border = "";
    document.all.lineWidth7.style.border = "";
    document.all.lineWidth15.style.border = "";
    document.all.lineWidth3.style.border = "solid 1px black";
    lineWidth = 3;
    saveSettings();
  });

  document.all.lineWidth7.addEventListener('click', () => {
    document.all.lineWidth1.style.border = "";
    document.all.lineWidth3.style.border = "";
    document.all.lineWidth15.style.border = "";
    document.all.lineWidth7.style.border = "solid 1px black";
    lineWidth = 7;
    saveSettings();
  });

  document.all.lineWidth15.addEventListener('click', () => {
    document.all.lineWidth1.style.border = "";
    document.all.lineWidth3.style.border = "";
    document.all.lineWidth7.style.border = "";
    document.all.lineWidth15.style.border = "solid 1px black";
    lineWidth = 15;
    saveSettings();
  });

  document.all.pclyrs_add.addEventListener('click', () => {
    const layer = document.createElement('canvas');
    layer.id = 'pclyr' + layerId;
<!--      <canvas id="layer1" width="480" height="360" style="position: absolute; left: 0px; top: 0px; background-color: transparent; z-index:3;"></canvas>-->
    pclyrs.appendChild(layer);
    const row = document.all.pclyrs_mng.insertRow(1);
    const cellLayer = row.insertCell(-1);
    cellLayer.innerHTML = '<input id="pclyr' + layerId + 's" type="radio" name="pclyrs_s" /><label for="pclyr' + layerId + 's">' + layerId.toString() + "</label>";
    const cellVisibility = row.insertCell(-1);
    cellVisibility.align = 'center';
    cellVisibility.innerHTML = '<input type="checkbox" id="pclyr' + layerId + 'v" checked="checked" />';
    const cellUp = row.insertCell(-1);
    cellUp.innerHTML = '<button>↑</button>';
    const cellDown = row.insertCell(-1);
    cellDown.innerHTML = '<button>↓</button>';
    const cellTransparency = row.insertCell(-1);
    cellTransparency.innerHTML = '<input type="number" id="pclyr' + layerId + 'o" min="0" max="100" value="0" />';
    layerId++;
  });

  document.all.sizel.addEventListener('click', () => {
    document.all.pclyrs.style.width = '640px';
    document.all.pclyrs.style.height = '480px';
    redrawCanvas();
  });

  document.all.sizem.addEventListener('click', () => {
    document.all.pclyrs.style.width = '480px';
    document.all.pclyrs.style.height = '360px';
    redrawCanvas();
  });

  document.all.sizes.addEventListener('click', () => {
    document.all.pclyrs.style.width = '320px';
    document.all.pclyrs.style.height = '240px';
    redrawCanvas();
  });

  document.all.undo.addEventListener('click', () => {
    undoBuffer.push(new StrokeData(0, null, null, null, null, null));
    for (let sd = strokes.pop(); sd.lineWidth !== 0; sd = strokes.pop()) {
      clearCanvas(
          Math.min(sd.pt1.x, sd.pt2.x) - sd.lineWidth - 1,
          Math.min(sd.pt1.y, sd.pt2.y) - sd.lineWidth - 1,
          Math.abs(sd.pt1.x - sd.pt2.x) + (sd.lineWidth + 1) * 2,
          Math.abs(sd.pt1.y - sd.pt2.y) + (sd.lineWidth + 1) * 2);
      undoBuffer.push(sd);
    }
    redrawCanvas();
    saveStorage(LOCALSTORAGE_KEY_STROKES, strokes);
  });

  document.all.redo.addEventListener('click', () => {
    strokes.push(new StrokeData(0, null, null, null, null, null));
    for (let sd = undoBuffer.pop(); sd.lineWidth !== 0; sd = undoBuffer.pop()) {
      clearCanvas(
          Math.min(sd.pt1.x, sd.pt2.x) - sd.lineWidth - 1,
          Math.min(sd.pt1.y, sd.pt2.y) - sd.lineWidth - 1,
          Math.abs(sd.pt1.x - sd.pt2.x) + (sd.lineWidth + 1) * 2,
          Math.abs(sd.pt1.y - sd.pt2.y) + (sd.lineWidth + 1) * 2);
      strokes.push(sd);
    }
    redrawCanvas();
    saveStorage(LOCALSTORAGE_KEY_STROKES, strokes);
  });

  document.all.erase.addEventListener('click', () => {
    strokes.length = 0;
    undoBuffer.length = 0;
    clearCanvas();
    saveStorage(LOCALSTORAGE_KEY_STROKES, strokes);
  });

  document.all.pclyrs.addEventListener('mousedown', (e) => {
    const rect = e.target.getBoundingClientRect();
    prevX = e.clientX - rect.left;
    prevY = e.clientY - rect.top;
    lineCount = 0;
    undoBuffer.length = 0;
    strokes.push(new StrokeData(0, null, null, null, null, null));
  });

  document.all.pclyrs.addEventListener('mousemove', (e) => {
    if (prevX == null || prevY == null) {
      return;
    }
    const rect = e.target.getBoundingClientRect();
    x = e.clientX - rect.left;
    y = e.clientY - rect.top;
    if (prevX === x && prevY === y) {
      // 同じ地点の場合、何もしない。
    } else {
      drawLine(lineWidth, picker.getHexColor(), prevX, prevY, x, y);
      strokes.push(new StrokeData(lineWidth, picker.getHexColor(), prevX, prevY, x, y));
      lineCount++;
    }
    prevX = x;
    prevY = y;
  });

  document.all.pclyrs.addEventListener('mouseup', (e) => {
    if (prevX == null || prevY == null) {
      return;
    }
    const rect = e.target.getBoundingClientRect();
    x = e.clientX - rect.left;
    y = e.clientY - rect.top;
    if (prevX === x && prevY === y) {
      if (lineCount === 0) {
        drawPoint(lineWidth, picker.getHexColor(), x, y);
        strokes.push(new StrokeData(lineWidth, picker.getHexColor(), x, y, x, y));
      }
    } else {
      drawLine(lineWidth, picker.getHexColor(), prevX, prevY, x, y);
      strokes.push(new StrokeData(lineWidth, picker.getHexColor(), prevX, prevY, x, y));
      lineCount++;
    }
    prevX = null;
    prevY = null;
    saveStorage(LOCALSTORAGE_KEY_STROKES, strokes);
  });

  document.all.pclyrs.addEventListener('mouseleave', (e) => {
    prevX = null;
    prevY = null;
  });

  const settings = loadSettings();
  if (settings != null) {
    if (settings.lw != null) {
      switch (settings.lw) {
        case 1:
          document.all.lineWidth1.click();
          break;
        case 3:
          document.all.lineWidth3.click();
          break;
        case 7:
          document.all.lineWidth7.click();
          break;
        case 15:
          document.all.lineWidth15.click();
          break;
      }
    }
    if (settings.lc != null) {
      picker.updateColor(settings.lc);
    }
  }

  localStorage.removeItem(LOCALSTORAGE_KEY_SETTINGS_OLD);
  localStorage.removeItem(LOCALSTORAGE_KEY_STROKES_OLD);
/*
  strokes = loadStorage(LOCALSTORAGE_KEY_STROKES);
  if (strokes) {
    for (let i = 0; i < strokes.length; i++) {
      strokes[i].pt1.equals = Point.prototype.equals;
      strokes[i].pt2.equals = Point.prototype.equals;
    }
  } else {
    strokes = new Array();
  }
  undoBuffer = new Array();
  redrawCanvas();
*/
  if (layers.length === 0) {
    document.all.pclyrs_add.click();
  }

});

function drawPoint(lw, lc, x, y) {
  //console.log(lw, lc, x1, y1);
  const ctx = document.all.layer1.getContext('2d');
  ctx.fillStyle = lc;
  ctx.beginPath();
  ctx.arc(x, y, lw / 2, 0, 2 * Math.PI, false);
  ctx.fill();
}

function drawLine(lw, lc, x1, y1, x2, y2) {
  //console.log(lw, lc, x1, y1, x2, y2);
  const ctx = document.all.layer1.getContext('2d');
  ctx.lineWidth = lw;
  ctx.strokeStyle = lc;
  ctx.lineCap = 'round';
  ctx.beginPath();
  ctx.moveTo(x1, y1);
  ctx.lineTo(x2, y2);
  ctx.stroke();
}

function clearCanvas(x, y, w, h) {
  const ctx = document.all.layer1.getContext('2d');
  if (x != null && w != null) {
    ctx.clearRect(x, y, w, h);
  } else {
    ctx.clearRect(0, 0, document.all.layer1.width, document.all.layer1.height);
  }
}

function redrawCanvas() {
  for (let i = 0; i < strokes.length; i++) {
    if (strokes[i].lineWidth === 0) {
      continue;
    }
    if (strokes[i].pt1.equals(strokes[i].pt2)) {
      drawPoint(
          strokes[i].lineWidth,
          strokes[i].lineColor,
          strokes[i].pt1.x,
          strokes[i].pt1.y);
    } else {
      drawLine(
          strokes[i].lineWidth,
          strokes[i].lineColor,
          strokes[i].pt1.x,
          strokes[i].pt1.y,
          strokes[i].pt2.x,
          strokes[i].pt2.y);
    }
  }
}

function saveSettings() {
  saveStorage(LOCALSTORAGE_KEY_SETTINGS, { 'lw': lineWidth, 'lc': picker.get8BitColor() });
}

function loadSettings() {
  return loadStorage(LOCALSTORAGE_KEY_SETTINGS);
}

function saveStorage(key, val) {
  const str = JSON.stringify(val);
  // console.log(str);
  localStorage.setItem(key, str);
}

function loadStorage(key) {
  const obj = localStorage.getItem(key);
  //console.log(obj);
  return JSON.parse(obj);
}

  </script>
</head>

<body>
  <div id="pc">
    <div id="pclyrs" style="position: relative; width: 480px; height: 360px; display: inline-block; vertical-align: top; border: solid 1px black; background-image: url('bg.png');">
    </div>
    <div style="position: relative; display: inline-block;">
      <div id="pcpal">
        <span id="ebcp" class="eight-bit-color-picker"></span>
      </div>
      <br />
      <div style="width: 34px;">
        <div id="lineWidth1" style="border: solid 1px black;"><img src="1.png" /></div>
        <div id="lineWidth3" style=""><img src="3.png" /></div>
        <div id="lineWidth7" style=""><img src="7.png" /></div>
        <div id="lineWidth15" style=""><img src="15.png" /></div>
      </div>
      <br />
      <table id="pclyrs_mng" border="1">
        <tr>
          <th align="center">レイヤー</th>
          <th align="center">表示</th>
          <th colspan="2" align="center">移動</th>
          <th align="center">透明度</th>
        </tr>
      </table>
      <button id="pclyrs_add">追加</button>
      <button id="pclyrs_remove">削除</button>
    </div>
  </div>
  <div>
    サイズ：<button id="sizel">大</button> <button id="sizem">中</button> <button id="sizes">小</button>&nbsp;&nbsp;&nbsp;&nbsp;<button id="undo">Undo</button> <button id="redo">Redo</button>&nbsp;&nbsp;&nbsp;&nbsp;<button id="erase">全消し</button>
  </div>
</body>

</html>
